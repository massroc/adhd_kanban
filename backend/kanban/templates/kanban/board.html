<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADHD Kanban Organizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f7fa;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }
        
        h1 {
            color: #2c3e50;
        }
        
        /* Subtle Column Management Button */
        .column-settings {
            position: absolute;
            top: 0;
            right: 20px;
        }
        
        #add-column-btn {
            background: transparent;
            color: #95a5a6;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #add-column-btn:hover {
            color: #27ae60;
            border-color: #27ae60;
            background: #eafaf1;
        }
        
        #add-column-btn:disabled {
            color: #bdc3c7;
            border-color: #ecf0f1;
            cursor: not-allowed;
            background: transparent;
        }
        
        .column-limit-msg {
            font-size: 12px;
            color: #e74c3c;
            display: none;
            margin-left: 10px;
        }
        
        .column-limit-msg.show {
            display: inline;
        }
        
        /* Add Task Button - Floating Action Button Style */
        #add-task-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #3498db;
            color: white;
            border: none;
            font-size: 30px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
            transition: all 0.3s;
            z-index: 100;
        }
        
        #add-task-btn:hover {
            background: #2980b9;
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(52, 152, 219, 0.5);
        }
        
        /* Modal Overlay */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-overlay.active {
            display: flex;
        }
        
        /* Modal Content */
        .modal {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal h2 {
            margin-bottom: 20px;
            color: #2c3e50;
        }
        
        .modal label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 500;
        }
        
        .modal input,
        .modal textarea,
        .modal select {
            width: 100%;
            padding: 12px;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            font-family: inherit;
        }
        
        .modal input:focus,
        .modal textarea:focus,
        .modal select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        .modal textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .modal-buttons button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #3498db;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2980b9;
        }
        
        .btn-secondary {
            background: #ecf0f1;
            color: #555;
        }
        
        .btn-secondary:hover {
            background: #d5dbdb;
        }
        
        /* Kanban Board - Single continuous row */
        .kanban-board {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px;
            max-width: 100%;
            margin: 0 auto;
            padding-bottom: 20px;
        }
        
        .column {
            flex: 1 1 0;
            min-width: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 500px;
            transition: box-shadow 0.2s;
            overflow: hidden;
        }
        
        .column:hover .column-controls {
            opacity: 1;
        }
        
        .column.drag-over {
            background-color: #e8f4f8;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        
        .column.column-dragging {
            opacity: 0.4;
        }
        
        .column.column-drag-over {
            border-left: 4px solid #3498db;
        }
        
        .column-header {
            padding: 10px 12px;
            font-weight: bold;
            font-size: 14px;
            border-bottom: 2px solid #ecf0f1;
            text-align: center;
            color: #2c3e50;
            border-bottom-color: #3498db;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .drag-handle {
            font-size: 12px;
            color: #bdc3c7;
            cursor: grab;
            user-select: none;
            opacity: 0.5;
            transition: opacity 0.2s;
            flex-shrink: 0;
        }
        
        .column:hover .drag-handle {
            opacity: 1;
            color: #95a5a6;
        }
        
        .drag-handle:hover {
            color: #3498db;
        }
        
        .column-title {
            flex: 1;
            min-width: 0;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .column-title:hover {
            background: #ecf0f1;
        }
        
        .column-title-input {
            flex: 1;
            border: 2px solid #3498db;
            padding: 4px 8px;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            font-family: inherit;
            border-radius: 4px;
        }
        
        .column-controls {
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .delete-column {
            background: transparent;
            color: #e74c3c;
            border: none;
            border-radius: 3px;
            padding: 2px 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .delete-column:hover {
            background: #e74c3c;
            color: white;
        }
        
        .tasks {
            padding: 10px;
            min-height: 400px;
        }
        
        .task {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: grab;
            transition: all 0.2s;
            user-select: none;
            position: relative;
        }
        
        .task:hover .task-controls {
            opacity: 1;
        }
        
        .task-controls {
            position: absolute;
            top: 6px;
            right: 6px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: all 0.2s;
        }
        
        .task-edit,
        .task-delete {
            background: transparent;
            border: none;
            border-radius: 3px;
            padding: 2px 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .task-edit {
            color: #95a5a6;
        }
        
        .task-edit:hover {
            background: #3498db;
            color: white;
        }
        
        .task-delete {
            color: #e74c3c;
        }
        
        .task-delete:hover {
            background: #e74c3c;
            color: white;
        }
        
        .task:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .task.dragging {
            opacity: 0.5;
            transform: rotate(3deg);
            cursor: grabbing;
        }
        
        .task.drag-over-task {
            border-top: 3px solid #3498db;
        }
        
        .task-title {
            font-weight: bold;
            margin-bottom: 6px;
            color: #2c3e50;
            font-size: 13px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            padding-right: 45px;
        }
        
        .task-description {
            color: #7f8c8d;
            font-size: 12px;
            line-height: 1.4;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .task-meta {
            font-size: 10px;
            color: #95a5a6;
            margin-top: 6px;
        }
        
        .empty-column {
            text-align: center;
            color: #bdc3c7;
            font-size: 12px;
            font-style: italic;
            margin-top: 50px;
            padding: 0 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 id="page-title">ðŸ§  ADHD Kanban Organizer</h1>
        <div class="column-settings">
            <button id="add-column-btn" title="Add new column">+ Column</button>
            <span class="column-limit-msg" id="column-limit-msg">Max 12</span>
        </div>
    </div>
    
    <!-- Floating Add Task Button -->
    <button id="add-task-btn" aria-label="Add new task">+</button>
    
    <!-- Modal for Adding Tasks -->
    <div class="modal-overlay" id="task-modal">
        <div class="modal">
            <h2>Add New Task</h2>
            <form method="post" action="{% url 'add_task' %}" id="add-task-form">
                {% csrf_token %}
                
                <label for="task-title">Title *</label>
                <input id="task-title" type="text" name="title" placeholder="What needs to be done?" required aria-required="true">
                
                <label for="task-description">Description</label>
                <textarea id="task-description" name="description" placeholder="Additional details (optional)" rows="3"></textarea>
                
                <label for="task-column">Column</label>
                <select id="task-column" name="column_id">
                    {% for column in columns %}
                    <option value="{{ column.id }}">{{ column.name }}</option>
                    {% endfor %}
                </select>
                
                <div class="modal-buttons">
                    <button type="button" class="btn-secondary" id="cancel-btn">Cancel</button>
                    <button type="submit" class="btn-primary">Add Task</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Modal for Adding Column -->
    <div class="modal-overlay" id="column-modal">
        <div class="modal">
            <h2>Add New Column</h2>
            <form method="post" action="{% url 'add_column' %}" id="add-column-form">
                {% csrf_token %}
                
                <label for="column-name">Column Name *</label>
                <input id="column-name" type="text" name="name" placeholder="e.g., Blocked, Review" required aria-required="true">
                
                <div class="modal-buttons">
                    <button type="button" class="btn-secondary" id="cancel-column-btn">Cancel</button>
                    <button type="submit" class="btn-primary">Add Column</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Modal for Editing Task -->
    <div class="modal-overlay" id="edit-task-modal">
        <div class="modal">
            <h2>Edit Task</h2>
            <form id="edit-task-form">
                <input type="hidden" id="edit-task-id" value="">
                
                <label for="edit-task-title">Title *</label>
                <input id="edit-task-title" type="text" name="title" placeholder="What needs to be done?" required aria-required="true">
                
                <label for="edit-task-description">Description</label>
                <textarea id="edit-task-description" name="description" placeholder="Additional details (optional)" rows="3"></textarea>
                
                <div class="modal-buttons">
                    <button type="button" class="btn-secondary" id="cancel-edit-btn">Cancel</button>
                    <button type="submit" class="btn-primary">Save Changes</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Kanban Board -->
    <div class="kanban-board">
        {% for column in columns %}
        <div class="column" data-column-id="{{ column.id }}" data-column-order="{{ column.order }}" role="region" aria-labelledby="column-header-{{ column.id }}">
            <div id="column-header-{{ column.id }}" class="column-header">
                <span class="drag-handle" title="Drag to reorder">â‹®</span>
                <div class="column-title" data-column-id="{{ column.id }}">
                    {{ column.name }} ({{ column.tasks.count }})
                </div>
                <div class="column-controls">
                    <button class="delete-column" data-column-id="{{ column.id }}" aria-label="Delete column" title="Delete column">Ã—</button>
                </div>
            </div>
            <div class="tasks" role="list">
                {% for task in column.tasks.all %}
                <div class="task" data-task-id="{{ task.id }}" data-order="{{ task.order }}" draggable="true" role="listitem" aria-grabbed="false">
                    <div class="task-controls">
                        <button class="task-edit" data-task-id="{{ task.id }}" aria-label="Edit task" title="Edit task">âœŽ</button>
                        <button class="task-delete" data-task-id="{{ task.id }}" aria-label="Delete task" title="Delete task">Ã—</button>
                    </div>
                    <div class="task-title">{{ task.title }}</div>
                    {% if task.description %}
                    <div class="task-description">{{ task.description }}</div>
                    {% endif %}
                    <div class="task-meta">{{ task.created_at|date:"M d" }}</div>
                </div>
                {% empty %}
                <div class="empty-column" role="note">No tasks yet</div>
                {% endfor %}
            </div>
        </div>
        {% endfor %}
    </div>

    <script>
        // API base URL
        const API_BASE = '/api/v1';
        
        // Get CSRF token
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        // Common fetch options for API calls
        function apiHeaders() {
            return {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            };
        }
        
        // Column count management
        let currentColumnCount = {{ columns|length }};
        const MAX_COLUMNS = 12;
        
        function updateColumnLimitUI() {
            const addBtn = document.getElementById('add-column-btn');
            const limitMsg = document.getElementById('column-limit-msg');
            if (currentColumnCount >= MAX_COLUMNS) {
                addBtn.disabled = true;
                limitMsg.classList.add('show');
            } else {
                addBtn.disabled = false;
                limitMsg.classList.remove('show');
            }
        }
        
        updateColumnLimitUI();
        
        // Helper: Update column task count display
        function updateColumnTaskCount(columnElement) {
            const tasksContainer = columnElement.querySelector('.tasks');
            const taskCount = tasksContainer.querySelectorAll('.task').length;
            const columnTitle = columnElement.querySelector('.column-title');
            const titleText = columnTitle.textContent.split('(')[0].trim();
            columnTitle.textContent = `${titleText} (${taskCount})`;
            
            // Add empty message if no tasks left
            if (taskCount === 0 && !tasksContainer.querySelector('.empty-column')) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'empty-column';
                emptyDiv.setAttribute('role', 'note');
                emptyDiv.textContent = 'No tasks yet';
                tasksContainer.appendChild(emptyDiv);
            }
        }
        
        // Task Modal Controls
        const taskModal = document.getElementById('task-modal');
        const addTaskBtn = document.getElementById('add-task-btn');
        const cancelTaskBtn = document.getElementById('cancel-btn');
        const taskForm = document.getElementById('add-task-form');
        
        addTaskBtn.addEventListener('click', () => {
            taskModal.classList.add('active');
            document.getElementById('task-title').focus();
        });
        
        cancelTaskBtn.addEventListener('click', () => {
            taskModal.classList.remove('active');
            taskForm.reset();
        });
        
        taskModal.addEventListener('click', (e) => {
            if (e.target === taskModal) {
                taskModal.classList.remove('active');
                taskForm.reset();
            }
        });
        
        // Column Modal Controls
        const columnModal = document.getElementById('column-modal');
        const addColumnBtn = document.getElementById('add-column-btn');
        const cancelColumnBtn = document.getElementById('cancel-column-btn');
        const columnForm = document.getElementById('add-column-form');
        
        addColumnBtn.addEventListener('click', () => {
            if (currentColumnCount < MAX_COLUMNS) {
                columnModal.classList.add('active');
                document.getElementById('column-name').focus();
            }
        });
        
        cancelColumnBtn.addEventListener('click', () => {
            columnModal.classList.remove('active');
            columnForm.reset();
        });
        
        columnModal.addEventListener('click', (e) => {
            if (e.target === columnModal) {
                columnModal.classList.remove('active');
                columnForm.reset();
            }
        });
        
        // Edit Task Modal Controls
        const editTaskModal = document.getElementById('edit-task-modal');
        const editTaskForm = document.getElementById('edit-task-form');
        const cancelEditBtn = document.getElementById('cancel-edit-btn');
        
        cancelEditBtn.addEventListener('click', () => {
            editTaskModal.classList.remove('active');
            editTaskForm.reset();
        });
        
        editTaskModal.addEventListener('click', (e) => {
            if (e.target === editTaskModal) {
                editTaskModal.classList.remove('active');
                editTaskForm.reset();
            }
        });
        
        // Open edit modal when clicking edit button
        document.querySelectorAll('.task-edit').forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.stopPropagation();
                e.preventDefault();
                
                const taskCard = this.closest('.task');
                const taskId = this.dataset.taskId;
                const titleEl = taskCard.querySelector('.task-title');
                const descEl = taskCard.querySelector('.task-description');
                
                document.getElementById('edit-task-id').value = taskId;
                document.getElementById('edit-task-title').value = titleEl.textContent;
                document.getElementById('edit-task-description').value = descEl ? descEl.textContent : '';
                
                editTaskModal.classList.add('active');
                document.getElementById('edit-task-title').focus();
            });
        });
        
        // Handle edit form submission - uses REST API PATCH
        editTaskForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const taskId = document.getElementById('edit-task-id').value;
            const title = document.getElementById('edit-task-title').value.trim();
            const description = document.getElementById('edit-task-description').value.trim();
            
            if (!title) return;
            
            fetch(`${API_BASE}/tasks/${taskId}/`, {
                method: 'PATCH',
                headers: apiHeaders(),
                body: JSON.stringify({
                    title: title,
                    description: description
                })
            })
            .then(response => {
                if (!response.ok) throw new Error('Failed to update task');
                return response.json();
            })
            .then(data => {
                // Update the task card without reloading
                const taskCard = document.querySelector(`.task[data-task-id="${taskId}"]`);
                const titleEl = taskCard.querySelector('.task-title');
                let descEl = taskCard.querySelector('.task-description');
                
                titleEl.textContent = data.title;
                
                if (data.description) {
                    if (descEl) {
                        descEl.textContent = data.description;
                    } else {
                        descEl = document.createElement('div');
                        descEl.className = 'task-description';
                        descEl.textContent = data.description;
                        titleEl.after(descEl);
                    }
                } else if (descEl) {
                    descEl.remove();
                }
                
                editTaskModal.classList.remove('active');
                editTaskForm.reset();
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Failed to save changes');
            });
        });
        
        // Delete Task - uses REST API DELETE
        document.querySelectorAll('.task-delete').forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.stopPropagation();
                e.preventDefault();
                
                const taskCard = this.closest('.task');
                const taskId = this.dataset.taskId;
                const taskTitle = taskCard.querySelector('.task-title').textContent.trim();
                
                if (confirm(`Delete "${taskTitle}"?`)) {
                    fetch(`${API_BASE}/tasks/${taskId}/`, {
                        method: 'DELETE',
                        headers: apiHeaders()
                    })
                    .then(response => {
                        if (!response.ok && response.status !== 204) {
                            throw new Error('Failed to delete task');
                        }
                        
                        const column = taskCard.closest('.column');
                        taskCard.remove();
                        updateColumnTaskCount(column);
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Failed to delete task');
                    });
                }
            });
        });
        
        // Close modals with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (taskModal.classList.contains('active')) {
                    taskModal.classList.remove('active');
                    taskForm.reset();
                }
                if (columnModal.classList.contains('active')) {
                    columnModal.classList.remove('active');
                    columnForm.reset();
                }
                if (editTaskModal.classList.contains('active')) {
                    editTaskModal.classList.remove('active');
                    editTaskForm.reset();
                }
            }
        });
        
        // Rename Column - Double click to edit, uses REST API PATCH
        function attachColumnTitleHandler(titleElement) {
            titleElement.addEventListener('dblclick', function(e) {
                e.stopPropagation();
                const columnId = this.dataset.columnId;
                const currentName = this.textContent.split('(')[0].trim();
                
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentName;
                input.className = 'column-title-input';
                
                this.replaceWith(input);
                input.focus();
                input.select();
                
                function restoreTitle(name) {
                    const column = document.querySelector(`.column[data-column-id="${columnId}"]`);
                    const taskCount = column.querySelectorAll('.task').length;
                    
                    const newTitle = document.createElement('div');
                    newTitle.className = 'column-title';
                    newTitle.dataset.columnId = columnId;
                    newTitle.textContent = `${name} (${taskCount})`;
                    
                    input.replaceWith(newTitle);
                    attachColumnTitleHandler(newTitle);
                }
                
                function saveRename() {
                    const newName = input.value.trim();
                    if (newName && newName !== currentName) {
                        fetch(`${API_BASE}/columns/${columnId}/`, {
                            method: 'PATCH',
                            headers: apiHeaders(),
                            body: JSON.stringify({ name: newName })
                        })
                        .then(response => {
                            if (!response.ok) throw new Error('Failed to rename column');
                            return response.json();
                        })
                        .then(data => {
                            restoreTitle(data.name);
                        })
                        .catch(error => {
                            console.error('Error:', error);
                            alert('Failed to rename column');
                            restoreTitle(currentName);
                        });
                    } else {
                        restoreTitle(currentName);
                    }
                }
                
                input.addEventListener('blur', saveRename);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                    } else if (e.key === 'Escape') {
                        restoreTitle(currentName);
                    }
                });
            });
        }
        
        // Attach handlers to all column titles
        document.querySelectorAll('.column-title').forEach(attachColumnTitleHandler);
        
        // Delete Column - uses REST API DELETE
        document.querySelectorAll('.delete-column').forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.stopPropagation();
                const columnId = this.dataset.columnId;
                const columnElement = this.closest('.column');
                const columnName = columnElement.querySelector('.column-title').textContent.split('(')[0].trim();
                
                if (currentColumnCount <= 1) {
                    alert('Cannot delete the last column');
                    return;
                }
                
                const taskCount = columnElement.querySelectorAll('.task').length;
                let confirmMsg = `Delete "${columnName}"?`;
                if (taskCount > 0) {
                    confirmMsg = `Delete "${columnName}"?\n\nâš ï¸ This will also delete ${taskCount} task${taskCount === 1 ? '' : 's'} in this column.`;
                }
                
                if (confirm(confirmMsg)) {
                    fetch(`${API_BASE}/columns/${columnId}/`, {
                        method: 'DELETE',
                        headers: apiHeaders()
                    })
                    .then(response => {
                        if (!response.ok && response.status !== 204) {
                            throw new Error('Failed to delete column');
                        }
                        
                        columnElement.remove();
                        currentColumnCount--;
                        updateColumnLimitUI();
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Failed to delete column');
                    });
                }
            });
        });
        
        // Column Drag and Drop
        let draggedColumn = null;
        let draggedTask = null;
        
        document.querySelectorAll('.drag-handle').forEach(handle => {
            handle.addEventListener('mousedown', function(e) {
                const header = this.closest('.column-header');
                const column = this.closest('.column');
                
                header.setAttribute('draggable', 'true');
                
                const dragStartHandler = function(e) {
                    draggedColumn = column;
                    column.classList.add('column-dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', column.innerHTML);
                };
                
                header.addEventListener('dragstart', dragStartHandler, { once: true });
                
                document.addEventListener('mouseup', function() {
                    header.removeAttribute('draggable');
                }, { once: true });
            });
        });
        
        document.addEventListener('dragend', function(e) {
            if (e.target.classList.contains('column-header')) {
                const column = e.target.closest('.column');
                if (column) {
                    column.classList.remove('column-dragging');
                }
                document.querySelectorAll('.column').forEach(col => {
                    col.classList.remove('column-drag-over');
                });
                draggedColumn = null;
            }
        });
        
        document.querySelectorAll('.column').forEach(column => {
            column.addEventListener('dragover', function(e) {
                if (draggedColumn && draggedColumn !== this && !draggedTask) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                }
            });
            
            column.addEventListener('dragenter', function(e) {
                if (draggedColumn && draggedColumn !== this && !draggedTask) {
                    this.classList.add('column-drag-over');
                }
            });
            
            column.addEventListener('dragleave', function(e) {
                if (e.target === this) {
                    this.classList.remove('column-drag-over');
                }
            });
            
            column.addEventListener('drop', function(e) {
                if (draggedColumn && draggedColumn !== this && !draggedTask) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const board = document.querySelector('.kanban-board');
                    const allColumns = Array.from(board.querySelectorAll('.column'));
                    const draggedIndex = allColumns.indexOf(draggedColumn);
                    const targetIndex = allColumns.indexOf(this);
                    
                    if (draggedIndex < targetIndex) {
                        this.parentNode.insertBefore(draggedColumn, this.nextSibling);
                    } else {
                        this.parentNode.insertBefore(draggedColumn, this);
                    }
                    
                    // Update order via REST API
                    const newOrder = Array.from(board.querySelectorAll('.column')).map((col, index) => ({
                        id: parseInt(col.dataset.columnId),
                        order: index + 1
                    }));
                    
                    fetch(`${API_BASE}/reorder-columns/`, {
                        method: 'POST',
                        headers: apiHeaders(),
                        body: JSON.stringify({ column_orders: newOrder })
                    })
                    .then(response => {
                        if (!response.ok) throw new Error('Failed to reorder columns');
                        return response.json();
                    })
                    .catch(error => {
                        console.error('Error:', error);
                    });
                    
                    this.classList.remove('column-drag-over');
                }
            });
        });
        
        // Task Drag and Drop
        document.addEventListener('dragstart', function(e) {
            if (e.target.classList.contains('task')) {
                draggedTask = e.target;
                e.target.classList.add('dragging');
                e.target.setAttribute('aria-grabbed', 'true');
                e.dataTransfer.setData('text/plain', e.target.dataset.taskId);
                e.dataTransfer.effectAllowed = 'move';
            }
        });
        
        document.addEventListener('dragend', function(e) {
            if (e.target.classList.contains('task')) {
                e.target.classList.remove('dragging');
                e.target.setAttribute('aria-grabbed', 'false');
                document.querySelectorAll('.column').forEach(col => {
                    col.classList.remove('drag-over');
                });
                document.querySelectorAll('.task').forEach(task => {
                    task.classList.remove('drag-over-task');
                });
                draggedTask = null;
            }
        });
        
        document.addEventListener('dragover', function(e) {
            if (draggedTask && !draggedColumn) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            }
        });
        
        document.addEventListener('dragenter', function(e) {
            if (draggedTask && !draggedColumn) {
                const targetTask = e.target.closest('.task');
                if (targetTask && targetTask !== draggedTask) {
                    document.querySelectorAll('.task').forEach(t => {
                        t.classList.remove('drag-over-task');
                    });
                    targetTask.classList.add('drag-over-task');
                }
            }
            
            const column = e.target.closest('.column');
            if (column && draggedTask && !draggedColumn) {
                document.querySelectorAll('.column').forEach(col => {
                    col.classList.remove('drag-over');
                });
                column.classList.add('drag-over');
            }
        });
        
        document.addEventListener('drop', function(e) {
            if (!draggedTask || draggedColumn) {
                return;
            }
            
            e.preventDefault();
            
            const column = e.target.closest('.column');
            const tasksContainer = column ? column.querySelector('.tasks') : null;
            
            if (tasksContainer && draggedTask) {
                const newColumnId = column.dataset.columnId;
                const taskId = draggedTask.dataset.taskId;
                
                const currentColumn = draggedTask.closest('.column');
                const currentColumnId = currentColumn.dataset.columnId;
                
                if (newColumnId === currentColumnId) {
                    // Reordering within same column
                    const dropTarget = e.target.closest('.task');
                    
                    if (dropTarget && dropTarget !== draggedTask) {
                        const tasksInColumn = Array.from(tasksContainer.querySelectorAll('.task'));
                        const draggedIndex = tasksInColumn.indexOf(draggedTask);
                        const targetIndex = tasksInColumn.indexOf(dropTarget);
                        
                        if (draggedIndex < targetIndex) {
                            dropTarget.parentNode.insertBefore(draggedTask, dropTarget.nextSibling);
                        } else {
                            dropTarget.parentNode.insertBefore(draggedTask, dropTarget);
                        }
                        
                        // Update via REST API
                        const newOrder = Array.from(tasksContainer.querySelectorAll('.task')).map((task, index) => ({
                            id: parseInt(task.dataset.taskId),
                            order: index + 1
                        }));
                        
                        fetch(`${API_BASE}/reorder-tasks/`, {
                            method: 'POST',
                            headers: apiHeaders(),
                            body: JSON.stringify({ task_orders: newOrder })
                        })
                        .then(response => {
                            if (!response.ok) throw new Error('Failed to reorder tasks');
                            return response.json();
                        })
                        .catch(error => {
                            console.error('Error:', error);
                            location.reload();
                        });
                    }
                } else {
                    // Moving to different column
                    const oldColumn = draggedTask.closest('.column');
                    const draggedTaskOrder = parseInt(draggedTask.dataset.order);
                    
                    const tasksInNewColumn = Array.from(tasksContainer.querySelectorAll('.task'));
                    let insertBeforeTask = null;
                    
                    for (let task of tasksInNewColumn) {
                        const taskOrder = parseInt(task.dataset.order);
                        if (taskOrder > draggedTaskOrder) {
                            insertBeforeTask = task;
                            break;
                        }
                    }
                    
                    if (insertBeforeTask) {
                        tasksContainer.insertBefore(draggedTask, insertBeforeTask);
                    } else {
                        tasksContainer.appendChild(draggedTask);
                    }
                    
                    const emptyMsg = tasksContainer.querySelector('.empty-column');
                    if (emptyMsg) {
                        emptyMsg.remove();
                    }
                    
                    updateColumnTaskCount(oldColumn);
                    updateColumnTaskCount(column);
                    
                    // Move via REST API
                    fetch(`${API_BASE}/tasks/${taskId}/move/`, {
                        method: 'POST',
                        headers: apiHeaders(),
                        body: JSON.stringify({ column_id: parseInt(newColumnId) })
                    })
                    .then(response => {
                        if (!response.ok) throw new Error('Failed to move task');
                        return response.json();
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        alert('Failed to move task');
                        location.reload();
                    });
                }
            }
            
            document.querySelectorAll('.column').forEach(col => {
                col.classList.remove('drag-over');
            });
        });
    </script>
</body>
</html>
